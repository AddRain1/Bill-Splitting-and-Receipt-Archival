{"ast":null,"code":"// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst path = require('node:path');\nconst is = require('./is');\nconst sharp = require('./sharp');\nconst formats = new Map([['heic', 'heif'], ['heif', 'heif'], ['avif', 'avif'], ['jpeg', 'jpeg'], ['jpg', 'jpeg'], ['jpe', 'jpeg'], ['tile', 'tile'], ['dz', 'tile'], ['png', 'png'], ['raw', 'raw'], ['tiff', 'tiff'], ['tif', 'tiff'], ['webp', 'webp'], ['gif', 'gif'], ['jp2', 'jp2'], ['jpx', 'jp2'], ['j2k', 'jp2'], ['j2c', 'jp2'], ['jxl', 'jxl']]);\nconst jp2Regex = /\\.(jp[2x]|j2[kc])$/i;\nconst errJp2Save = () => new Error('JP2 output requires libvips with support for OpenJPEG');\nconst bitdepthFromColourCount = colours => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));\n\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * The caller is responsible for ensuring directory structures and permissions exist.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {string} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * When using the attention crop strategy also contains `attentionX` and `attentionY`, the focal point of the cropped region.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\nfunction toFile(fileOut, callback) {\n  let err;\n  if (!is.string(fileOut)) {\n    err = new Error('Missing output file path');\n  } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {\n    err = new Error('Cannot use same file for input and output');\n  } else if (jp2Regex.test(path.extname(fileOut)) && !this.constructor.format.jp2k.output.file) {\n    err = errJp2Save();\n  }\n  if (err) {\n    if (is.fn(callback)) {\n      callback(err);\n    } else {\n      return Promise.reject(err);\n    }\n  } else {\n    this.options.fileOut = fileOut;\n    const stack = Error();\n    return this._pipeline(callback, stack);\n  }\n  return this;\n}\n\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.\n *\n * Use {@link #toformat|toFormat} or one of the format-specific functions such as {@link jpeg}, {@link png} etc. to set the output format.\n *\n * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .png()\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * const { data, info } = await sharp('my-image.jpg')\n *   // output the raw pixels\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * // create a more type safe way to work with the raw pixel data\n * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer\n * // so `data` and `pixelArray` point to the same memory location\n * const pixelArray = new Uint8ClampedArray(data.buffer);\n *\n * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input\n * const { width, height, channels } = info;\n * await sharp(pixelArray, { raw: { width, height, channels } })\n *   .toFile('my-changed-image.jpg');\n *\n * @param {Object} [options]\n * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\nfunction toBuffer(options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n  this.options.fileOut = '';\n  const stack = Error();\n  return this._pipeline(is.fn(options) ? options : callback, stack);\n}\n\n/**\n * Keep all EXIF metadata from the input image in the output image.\n *\n * EXIF metadata is unsupported for TIFF output.\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithExif = await sharp(inputWithExif)\n *   .keepExif()\n *   .toBuffer();\n *\n * @returns {Sharp}\n */\nfunction keepExif() {\n  this.options.keepMetadata |= 0b00001;\n  return this;\n}\n\n/**\n * Set EXIF metadata in the output image, ignoring any EXIF in the input image.\n *\n * @since 0.33.0\n *\n * @example\n * const dataWithExif = await sharp(input)\n *   .withExif({\n *     IFD0: {\n *       Copyright: 'The National Gallery'\n *     },\n *     IFD3: {\n *       GPSLatitudeRef: 'N',\n *       GPSLatitude: '51/1 30/1 3230/100',\n *       GPSLongitudeRef: 'W',\n *       GPSLongitude: '0/1 7/1 4366/100'\n *     }\n *   })\n *   .toBuffer();\n *\n * @param {Object<string, Object<string, string>>} exif Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withExif(exif) {\n  if (is.object(exif)) {\n    for (const [ifd, entries] of Object.entries(exif)) {\n      if (is.object(entries)) {\n        for (const [k, v] of Object.entries(entries)) {\n          if (is.string(v)) {\n            this.options.withExif[`exif-${ifd.toLowerCase()}-${k}`] = v;\n          } else {\n            throw is.invalidParameterError(`${ifd}.${k}`, 'string', v);\n          }\n        }\n      } else {\n        throw is.invalidParameterError(ifd, 'object', entries);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('exif', 'object', exif);\n  }\n  this.options.withExifMerge = false;\n  return this.keepExif();\n}\n\n/**\n * Update EXIF metadata from the input image in the output image.\n *\n * @since 0.33.0\n *\n * @example\n * const dataWithMergedExif = await sharp(inputWithExif)\n *   .withExifMerge({\n *     IFD0: {\n *       Copyright: 'The National Gallery'\n *     }\n *   })\n *   .toBuffer();\n *\n * @param {Object<string, Object<string, string>>} exif Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withExifMerge(exif) {\n  this.withExif(exif);\n  this.options.withExifMerge = true;\n  return this;\n}\n\n/**\n * Keep ICC profile from the input image in the output image.\n *\n * Where necessary, will attempt to convert the output colour space to match the profile.\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithIccProfile = await sharp(inputWithIccProfile)\n *   .keepIccProfile()\n *   .toBuffer();\n *\n * @returns {Sharp}\n */\nfunction keepIccProfile() {\n  this.options.keepMetadata |= 0b01000;\n  return this;\n}\n\n/**\n * Transform using an ICC profile and attach to the output image.\n *\n * This can either be an absolute filesystem path or\n * built-in profile name (`srgb`, `p3`, `cmyk`).\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithP3 = await sharp(input)\n *   .withIccProfile('p3')\n *   .toBuffer();\n *\n * @param {string} icc - Absolute filesystem path to output ICC profile or built-in profile name (srgb, p3, cmyk).\n * @param {Object} [options]\n * @param {number} [options.attach=true] Should the ICC profile be included in the output image metadata?\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withIccProfile(icc, options) {\n  if (is.string(icc)) {\n    this.options.withIccProfile = icc;\n  } else {\n    throw is.invalidParameterError('icc', 'string', icc);\n  }\n  this.keepIccProfile();\n  if (is.object(options)) {\n    if (is.defined(options.attach)) {\n      if (is.bool(options.attach)) {\n        if (!options.attach) {\n          this.options.keepMetadata &= ~0b01000;\n        }\n      } else {\n        throw is.invalidParameterError('attach', 'boolean', options.attach);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Keep all metadata (EXIF, ICC, XMP, IPTC) from the input image in the output image.\n *\n * The default behaviour, when `keepMetadata` is not used, is to convert to the device-independent\n * sRGB colour space and strip all metadata, including the removal of any ICC profile.\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithMetadata = await sharp(inputWithMetadata)\n *   .keepMetadata()\n *   .toBuffer();\n *\n * @returns {Sharp}\n */\nfunction keepMetadata() {\n  this.options.keepMetadata = 0b11111;\n  return this;\n}\n\n/**\n * Keep most metadata (EXIF, XMP, IPTC) from the input image in the output image.\n *\n * This will also convert to and add a web-friendly sRGB ICC profile if appropriate.\n *\n * Allows orientation and density to be set or updated.\n *\n * @example\n * const outputSrgbWithMetadata = await sharp(inputRgbWithMetadata)\n *   .withMetadata()\n *   .toBuffer();\n *\n * @example\n * // Set output metadata to 96 DPI\n * const data = await sharp(input)\n *   .withMetadata({ density: 96 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.orientation] Used to update the EXIF `Orientation` tag, integer between 1 and 8.\n * @param {number} [options.density] Number of pixels per inch (DPI).\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withMetadata(options) {\n  this.keepMetadata();\n  this.withIccProfile('srgb');\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n    if (is.defined(options.density)) {\n      if (is.number(options.density) && options.density > 0) {\n        this.options.withMetadataDensity = options.density;\n      } else {\n        throw is.invalidParameterError('density', 'positive number', options.density);\n      }\n    }\n    if (is.defined(options.icc)) {\n      this.withIccProfile(options.icc);\n    }\n    if (is.defined(options.exif)) {\n      this.withExifMerge(options.exif);\n    }\n  }\n  return this;\n}\n\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(string|Object)} format - as a string or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\nfunction toFormat(format, options) {\n  const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n  return this[actualFormat](options);\n}\n\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @example\n * // Use mozjpeg to reduce output JPEG file size (slower)\n * const data = await sharp(input)\n *   .jpeg({ mozjpeg: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {string} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling otherwise defaults to '4:2:0' chroma subsampling\n * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`\n * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation\n * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing\n * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive\n * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8\n * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jpeg(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n    if (is.defined(options.mozjpeg)) {\n      if (is.bool(options.mozjpeg)) {\n        if (options.mozjpeg) {\n          this.options.jpegTrellisQuantisation = true;\n          this.options.jpegOvershootDeringing = true;\n          this.options.jpegOptimiseScans = true;\n          this.options.jpegProgressive = true;\n          this.options.jpegQuantisationTable = 3;\n        }\n      } else {\n        throw is.invalidParameterError('mozjpeg', 'boolean', options.mozjpeg);\n      }\n    }\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n  return this._updateFormatOut('jpeg', options);\n}\n\n/**\n * Use these PNG options for output image.\n *\n * By default, PNG output is full colour at 8 bits per pixel.\n *\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n * Set `palette` to `true` for slower, indexed PNG output.\n *\n * For 16 bits per pixel output, convert to `rgb16` via\n * {@link /api-colour#tocolourspace|toColourspace}.\n *\n * @example\n * // Convert any input to full colour PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @example\n * // Convert any input to indexed PNG output (slower)\n * const data = await sharp(input)\n *   .png({ palette: true })\n *   .toBuffer();\n *\n * @example\n * // Output 16 bits per pixel RGB(A)\n * const data = await sharp(input)\n *  .toColourspace('rgb16')\n *  .png()\n *  .toBuffer();\n *\n * @param {Object} [options]\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)\n * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support\n * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`\n * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`\n * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction png(options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.pngBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n    } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {\n      this._setBooleanOption('pngPalette', true);\n    }\n    if (this.options.pngPalette) {\n      if (is.defined(options.quality)) {\n        if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n          this.options.pngQuality = options.quality;\n        } else {\n          throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n        }\n      }\n      if (is.defined(options.effort)) {\n        if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {\n          this.options.pngEffort = options.effort;\n        } else {\n          throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n        }\n      }\n      if (is.defined(options.dither)) {\n        if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n          this.options.pngDither = options.dither;\n        } else {\n          throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n        }\n      }\n    }\n  }\n  return this._updateFormatOut('png', options);\n}\n\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Optimise the file size of an animated WebP\n * const outputWebp = await sharp(inputWebp, { animated: true })\n *   .webp({ effort: 6 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {string} [options.preset='default'] - named preset for preprocessing/filtering, one of: default, photo, picture, drawing, icon, text\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.minSize=false] - prevent use of animation key frames to minimise file size (slow)\n * @param {boolean} [options.mixed=false] - allow mixture of lossy and lossless animation frames (slow)\n * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction webp(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.webpQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.alphaQuality)) {\n      if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n        this.options.webpAlphaQuality = options.alphaQuality;\n      } else {\n        throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      this._setBooleanOption('webpLossless', options.lossless);\n    }\n    if (is.defined(options.nearLossless)) {\n      this._setBooleanOption('webpNearLossless', options.nearLossless);\n    }\n    if (is.defined(options.smartSubsample)) {\n      this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n    }\n    if (is.defined(options.preset)) {\n      if (is.string(options.preset) && is.inArray(options.preset, ['default', 'photo', 'picture', 'drawing', 'icon', 'text'])) {\n        this.options.webpPreset = options.preset;\n      } else {\n        throw is.invalidParameterError('preset', 'one of: default, photo, picture, drawing, icon, text', options.preset);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {\n        this.options.webpEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 6', options.effort);\n      }\n    }\n    if (is.defined(options.minSize)) {\n      this._setBooleanOption('webpMinSize', options.minSize);\n    }\n    if (is.defined(options.mixed)) {\n      this._setBooleanOption('webpMixed', options.mixed);\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('webp', options);\n}\n\n/**\n * Use these GIF options for the output image.\n *\n * The first entry in the palette is reserved for transparency.\n *\n * The palette of the input image will be re-used if possible.\n *\n * @since 0.30.0\n *\n * @example\n * // Convert PNG to GIF\n * await sharp(pngBuffer)\n *   .gif()\n *   .toBuffer();\n *\n * @example\n * // Convert animated WebP to animated GIF\n * await sharp('animated.webp', { animated: true })\n *   .toFile('animated.gif');\n *\n * @example\n * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF\n * const out = await sharp('in.gif', { animated: true })\n *   .resize({ width: 128, height: 128 })\n *   .gif({ dither: 0 })\n *   .toBuffer();\n *\n * @example\n * // Lossy file size reduction of animated GIF\n * await sharp('in.gif', { animated: true })\n *   .gif({ interFrameMaxError: 8 })\n *   .toFile('optim.gif');\n *\n * @param {Object} [options] - output options\n * @param {boolean} [options.reuse=true] - re-use existing palette, otherwise generate new (slow)\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)\n * @param {number} [options.interFrameMaxError=0] - maximum inter-frame error for transparency, between 0 (lossless) and 32\n * @param {number} [options.interPaletteMaxError=3] - maximum inter-palette error for palette reuse, between 0 and 256\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction gif(options) {\n  if (is.object(options)) {\n    if (is.defined(options.reuse)) {\n      this._setBooleanOption('gifReuse', options.reuse);\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('gifProgressive', options.progressive);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.gifBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {\n        this.options.gifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n      }\n    }\n    if (is.defined(options.dither)) {\n      if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n        this.options.gifDither = options.dither;\n      } else {\n        throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n      }\n    }\n    if (is.defined(options.interFrameMaxError)) {\n      if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {\n        this.options.gifInterFrameMaxError = options.interFrameMaxError;\n      } else {\n        throw is.invalidParameterError('interFrameMaxError', 'number between 0.0 and 32.0', options.interFrameMaxError);\n      }\n    }\n    if (is.defined(options.interPaletteMaxError)) {\n      if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {\n        this.options.gifInterPaletteMaxError = options.interPaletteMaxError;\n      } else {\n        throw is.invalidParameterError('interPaletteMaxError', 'number between 0.0 and 256.0', options.interPaletteMaxError);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('gif', options);\n}\n\n/* istanbul ignore next */\n/**\n * Use these JP2 options for output image.\n *\n * Requires libvips compiled with support for OpenJPEG.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n * // Convert any input to lossless JP2 output\n * const data = await sharp(input)\n *   .jp2({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Convert any input to very high quality JP2 output\n * const data = await sharp(input)\n *   .jp2({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @since 0.29.1\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {number} [options.tileWidth=512] - horizontal tile size\n * @param {number} [options.tileHeight=512] - vertical tile size\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jp2(options) {\n  if (!this.constructor.format.jp2k.output.buffer) {\n    throw errJp2Save();\n  }\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jp2Quality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jp2Lossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {\n        this.options.jp2TileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer between 1 and 32768', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {\n        this.options.jp2TileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer between 1 and 32768', options.tileHeight);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jp2ChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('jp2', options);\n}\n\n/**\n * Set animation options if available.\n * @private\n *\n * @param {Object} [source] - output options\n * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)\n * @param {Object} [target] - target object for valid options\n * @throws {Error} Invalid options\n */\nfunction trySetAnimationOptions(source, target) {\n  if (is.object(source) && is.defined(source.loop)) {\n    if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {\n      target.loop = source.loop;\n    } else {\n      throw is.invalidParameterError('loop', 'integer between 0 and 65535', source.loop);\n    }\n  }\n  if (is.object(source) && is.defined(source.delay)) {\n    // We allow singular values as well\n    if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {\n      target.delay = [source.delay];\n    } else if (Array.isArray(source.delay) && source.delay.every(is.integer) && source.delay.every(v => is.inRange(v, 0, 65535))) {\n      target.delay = source.delay;\n    } else {\n      throw is.invalidParameterError('delay', 'integer or an array of integers between 0 and 65535', source.delay);\n    }\n  }\n}\n\n/**\n * Use these TIFF options for output image.\n *\n * The `density` can be set in pixels/inch via {@link #withmetadata|withMetadata}\n * instead of providing `xres` and `yres` in pixels/mm.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     bitdepth: 1\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {string} [options.compression='jpeg'] - compression options: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k\n * @param {string} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {boolean} [options.pyramid=false] - write an image pyramid\n * @param {boolean} [options.tile=false] - write a tiled tiff\n * @param {number} [options.tileWidth=256] - horizontal tile size\n * @param {number} [options.tileHeight=256] - vertical tile size\n * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {string} [options.resolutionUnit='inch'] - resolution unit options: inch, cm\n * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit\n * @param {boolean} [options.miniswhite=false] - write 1-bit images as miniswhite\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction tiff(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {\n        this.options.tiffBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '1, 2, 4 or 8', options.bitdepth);\n      }\n    }\n    // tiling\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    }\n    // miniswhite\n    if (is.defined(options.miniswhite)) {\n      this._setBooleanOption('tiffMiniswhite', options.miniswhite);\n    }\n    // pyramid\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    }\n    // resolution\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    }\n    // compression\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['none', 'jpeg', 'deflate', 'packbits', 'ccittfax4', 'lzw', 'webp', 'zstd', 'jp2k'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k', options.compression);\n      }\n    }\n    // predictor\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    }\n    // resolutionUnit\n    if (is.defined(options.resolutionUnit)) {\n      if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ['inch', 'cm'])) {\n        this.options.tiffResolutionUnit = options.resolutionUnit;\n      } else {\n        throw is.invalidParameterError('resolutionUnit', 'one of: inch, cm', options.resolutionUnit);\n      }\n    }\n  }\n  return this._updateFormatOut('tiff', options);\n}\n\n/**\n * Use these AVIF options for output image.\n *\n * AVIF image sequences are not supported.\n * Prebuilt binaries support a bitdepth of 8 only.\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ effort: 2 })\n *   .toBuffer();\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ lossless: true })\n *   .toBuffer();\n *\n * @since 0.27.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @param {number} [options.bitdepth=8] - set bitdepth to 8, 10 or 12 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction avif(options) {\n  return this.heif({\n    ...options,\n    compression: 'av1'\n  });\n}\n\n/**\n * Use these HEIF options for output image.\n *\n * Support for patent-encumbered HEIC images using `hevc` compression requires the use of a\n * globally-installed libvips compiled with support for libheif, libde265 and x265.\n *\n * @example\n * const data = await sharp(input)\n *   .heif({ compression: 'hevc' })\n *   .toBuffer();\n *\n * @since 0.23.0\n *\n * @param {Object} options - output options\n * @param {string} options.compression - compression format: av1, hevc\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @param {number} [options.bitdepth=8] - set bitdepth to 8, 10 or 12 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction heif(options) {\n  if (is.object(options)) {\n    if (is.string(options.compression) && is.inArray(options.compression, ['av1', 'hevc'])) {\n      this.options.heifCompression = options.compression;\n    } else {\n      throw is.invalidParameterError('compression', 'one of: av1, hevc', options.compression);\n    }\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {\n        this.options.heifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 9', options.effort);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [8, 10, 12])) {\n        if (options.bitdepth !== 8 && this.constructor.versions.heif) {\n          throw is.invalidParameterError('bitdepth when using prebuilt binaries', 8, options.bitdepth);\n        }\n        this.options.heifBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '8, 10 or 12', options.bitdepth);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('options', 'Object', options);\n  }\n  return this._updateFormatOut('heif', options);\n}\n\n/**\n * Use these JPEG-XL (JXL) options for output image.\n *\n * This feature is experimental, please do not use in production systems.\n *\n * Requires libvips compiled with support for libjxl.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * Image metadata (EXIF, XMP) is unsupported.\n *\n * @since 0.31.3\n *\n * @param {Object} [options] - output options\n * @param {number} [options.distance=1.0] - maximum encoding error, between 0 (highest quality) and 15 (lowest quality)\n * @param {number} [options.quality] - calculate `distance` based on JPEG-like quality, between 1 and 100, overrides distance if specified\n * @param {number} [options.decodingTier=0] - target decode speed tier, between 0 (highest quality) and 4 (lowest quality)\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=7] - CPU effort, between 3 (fastest) and 9 (slowest)\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jxl(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        // https://github.com/libjxl/libjxl/blob/0aeea7f180bafd6893c1db8072dcb67d2aa5b03d/tools/cjxl_main.cc#L640-L644\n        this.options.jxlDistance = options.quality >= 30 ? 0.1 + (100 - options.quality) * 0.09 : 53 / 3000 * options.quality * options.quality - 23 / 20 * options.quality + 25;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    } else if (is.defined(options.distance)) {\n      if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {\n        this.options.jxlDistance = options.distance;\n      } else {\n        throw is.invalidParameterError('distance', 'number between 0.0 and 15.0', options.distance);\n      }\n    }\n    if (is.defined(options.decodingTier)) {\n      if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {\n        this.options.jxlDecodingTier = options.decodingTier;\n      } else {\n        throw is.invalidParameterError('decodingTier', 'integer between 0 and 4', options.decodingTier);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jxlLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 3, 9)) {\n        this.options.jxlEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 3 and 9', options.effort);\n      }\n    }\n  }\n  return this._updateFormatOut('jxl', options);\n}\n\n/**\n * Force output to be raw, uncompressed pixel data.\n * Pixel ordering is left-to-right, top-to-bottom, without padding.\n * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.\n *\n * @example\n * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @example\n * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input\n * const data = await sharp('input.png')\n *   .ensureAlpha()\n *   .extractChannel(3)\n *   .toColourspace('b-w')\n *   .raw({ depth: 'ushort' })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {string} [options.depth='uchar'] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction raw(options) {\n  if (is.object(options)) {\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'complex', 'double', 'dpcomplex'])) {\n        this.options.rawDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex', options.depth);\n      }\n    }\n  }\n  return this._updateFormatOut('raw');\n}\n\n/**\n * Use tile-based deep zoom (image pyramid) output.\n *\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * The container will be set to `zip` when the output is a Buffer or Stream, otherwise it will default to `fs`.\n *\n * Requires libvips compiled with support for libgsf.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @example\n * const zipFileWithTiles = await sharp(input)\n *   .tile({ basename: \"tiles\" })\n *   .toBuffer();\n *\n * @example\n * const iiififier = sharp().tile({ layout: \"iiif\" });\n * readableStream\n *   .pipe(iiififier)\n *   .pipe(writeableStream);\n *\n * @param {Object} [options]\n * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {number} [options.skipBlanks=-1] Threshold to skip tile generation. Range is 0-255 for 8-bit images, 0-65535 for 16-bit images. Default is 5 for `google` layout, -1 (no skip) otherwise.\n * @param {string} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {string} [options.layout='dz'] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.\n * @param {boolean} [options.centre=false] centre image in tile.\n * @param {boolean} [options.center=false] alternative spelling of centre.\n * @param {string} [options.id='https://example.com/iiif'] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`\n * @param {string} [options.basename] the name of the directory within the zip file when container is `zip`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction tile(options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    }\n    // Overlap of tiles, in pixels\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    }\n    // Container\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    }\n    // Layout\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'iiif', 'iiif3', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, iiif, iiif3, zoomify', options.layout);\n      }\n    }\n    // Angle of rotation,\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    }\n    // Background colour\n    this._setBackgroundColourOption('tileBackground', options.background);\n    // Depth of tiles\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    }\n    // Threshold to skip blank tiles\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    }\n    // Center image in tile\n    const centre = is.bool(options.center) ? options.center : options.centre;\n    if (is.defined(centre)) {\n      this._setBooleanOption('tileCentre', centre);\n    }\n    // @id attribute for IIIF layout\n    if (is.defined(options.id)) {\n      if (is.string(options.id)) {\n        this.options.tileId = options.id;\n      } else {\n        throw is.invalidParameterError('id', 'string', options.id);\n      }\n    }\n    // Basename for zip container\n    if (is.defined(options.basename)) {\n      if (is.string(options.basename)) {\n        this.options.tileBasename = options.basename;\n      } else {\n        throw is.invalidParameterError('basename', 'string', options.basename);\n      }\n    }\n  }\n  // Format\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n  return this._updateFormatOut('dz');\n}\n\n/**\n * Set a timeout for processing, in seconds.\n * Use a value of zero to continue processing indefinitely, the default behaviour.\n *\n * The clock starts when libvips opens an input image for processing.\n * Time spent waiting for a libuv thread to become available is not included.\n *\n * @example\n * // Ensure processing takes no longer than 3 seconds\n * try {\n *   const data = await sharp(input)\n *     .blur(1000)\n *     .timeout({ seconds: 3 })\n *     .toBuffer();\n * } catch (err) {\n *   if (err.message.includes('timeout')) { ... }\n * }\n *\n * @since 0.29.2\n *\n * @param {Object} options\n * @param {number} options.seconds - Number of seconds after which processing will be stopped\n * @returns {Sharp}\n */\nfunction timeout(options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n  if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {\n    this.options.timeoutSeconds = options.seconds;\n  } else {\n    throw is.invalidParameterError('seconds', 'integer between 0 and 3600', options.seconds);\n  }\n  return this;\n}\n\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {string} formatOut\n * @param {Object} [options]\n * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\nfunction _updateFormatOut(formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n  return this;\n}\n\n/**\n * Update a boolean attribute of the this.options Object.\n * @private\n * @param {string} key\n * @param {boolean} val\n * @throws {Error} Invalid key\n */\nfunction _setBooleanOption(key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\nfunction _read() {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n    const stack = Error();\n    this._pipeline(undefined, stack);\n  }\n}\n\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\nfunction _pipeline(callback, stack) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            callback(is.nativeError(err, stack));\n          } else {\n            callback(null, data, info);\n          }\n        });\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          callback(is.nativeError(err, stack));\n        } else {\n          callback(null, data, info);\n        }\n      });\n    }\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', is.nativeError(err, stack));\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n          this.push(null);\n          this.on('end', () => this.emit('close'));\n        });\n      });\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', is.nativeError(err, stack));\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n        this.push(null);\n        this.on('end', () => this.emit('close'));\n      });\n    }\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(is.nativeError(err, stack));\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({\n                  data,\n                  info\n                });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(is.nativeError(err, stack));\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({\n                data,\n                info\n              });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    keepExif,\n    withExif,\n    withExifMerge,\n    keepIccProfile,\n    withIccProfile,\n    keepMetadata,\n    withMetadata,\n    toFormat,\n    jpeg,\n    jp2,\n    png,\n    webp,\n    tiff,\n    avif,\n    heif,\n    jxl,\n    gif,\n    raw,\n    tile,\n    timeout,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};","map":{"version":3,"names":["path","require","is","sharp","formats","Map","jp2Regex","errJp2Save","Error","bitdepthFromColourCount","colours","Math","clz32","ceil","log2","toFile","fileOut","callback","err","string","options","input","file","resolve","test","extname","constructor","format","jp2k","output","fn","Promise","reject","stack","_pipeline","toBuffer","object","_setBooleanOption","resolveWithObject","keepExif","keepMetadata","withExif","exif","ifd","entries","Object","k","v","toLowerCase","invalidParameterError","withExifMerge","keepIccProfile","withIccProfile","icc","defined","attach","bool","withMetadata","orientation","integer","inRange","withMetadataOrientation","density","number","withMetadataDensity","toFormat","actualFormat","get","id","keys","join","jpeg","quality","jpegQuality","progressive","chromaSubsampling","inArray","jpegChromaSubsampling","optimiseCoding","optimizeCoding","mozjpeg","jpegTrellisQuantisation","jpegOvershootDeringing","jpegOptimiseScans","jpegProgressive","jpegQuantisationTable","trellisQuantisation","trellisQuantization","overshootDeringing","optimiseScans","optimizeScans","quantisationTable","quantizationTable","_updateFormatOut","png","compressionLevel","pngCompressionLevel","adaptiveFiltering","colors","pngBitdepth","palette","effort","dither","some","pngPalette","pngQuality","pngEffort","pngDither","webp","webpQuality","alphaQuality","webpAlphaQuality","lossless","nearLossless","smartSubsample","preset","webpPreset","webpEffort","minSize","mixed","trySetAnimationOptions","gif","reuse","gifBitdepth","gifEffort","gifDither","interFrameMaxError","gifInterFrameMaxError","interPaletteMaxError","gifInterPaletteMaxError","jp2","buffer","jp2Quality","jp2Lossless","tileWidth","jp2TileWidth","tileHeight","jp2TileHeight","jp2ChromaSubsampling","source","target","loop","delay","Array","isArray","every","tiff","tiffQuality","bitdepth","tiffBitdepth","tile","tiffTileWidth","tiffTileHeight","miniswhite","pyramid","xres","tiffXres","yres","tiffYres","compression","tiffCompression","predictor","tiffPredictor","resolutionUnit","tiffResolutionUnit","avif","heif","heifCompression","heifQuality","heifLossless","heifEffort","heifChromaSubsampling","versions","heifBitdepth","jxl","jxlDistance","distance","decodingTier","jxlDecodingTier","jxlLossless","jxlEffort","raw","depth","rawDepth","size","tileSize","overlap","tileOverlap","container","tileContainer","layout","tileLayout","angle","tileAngle","_setBackgroundColourOption","background","tileDepth","skipBlanks","tileSkipBlanks","centre","center","tileId","basename","tileBasename","formatOut","tileFormat","timeout","plainObject","seconds","timeoutSeconds","force","key","val","_read","streamOut","undefined","_isStreamInput","on","_flattenBufferIn","pipeline","data","info","nativeError","once","emit","push","streamInFinished","module","exports","Sharp","assign","prototype"],"sources":["C:/Users/adria/OneDrive/Desktop/bill-splitting-and-receipt-archival/image-to-text/node_modules/sharp/lib/output.js"],"sourcesContent":["// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst path = require('node:path');\nconst is = require('./is');\nconst sharp = require('./sharp');\n\nconst formats = new Map([\n  ['heic', 'heif'],\n  ['heif', 'heif'],\n  ['avif', 'avif'],\n  ['jpeg', 'jpeg'],\n  ['jpg', 'jpeg'],\n  ['jpe', 'jpeg'],\n  ['tile', 'tile'],\n  ['dz', 'tile'],\n  ['png', 'png'],\n  ['raw', 'raw'],\n  ['tiff', 'tiff'],\n  ['tif', 'tiff'],\n  ['webp', 'webp'],\n  ['gif', 'gif'],\n  ['jp2', 'jp2'],\n  ['jpx', 'jp2'],\n  ['j2k', 'jp2'],\n  ['j2c', 'jp2'],\n  ['jxl', 'jxl']\n]);\n\nconst jp2Regex = /\\.(jp[2x]|j2[kc])$/i;\n\nconst errJp2Save = () => new Error('JP2 output requires libvips with support for OpenJPEG');\n\nconst bitdepthFromColourCount = (colours) => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));\n\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * The caller is responsible for ensuring directory structures and permissions exist.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {string} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * When using the attention crop strategy also contains `attentionX` and `attentionY`, the focal point of the cropped region.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\nfunction toFile (fileOut, callback) {\n  let err;\n  if (!is.string(fileOut)) {\n    err = new Error('Missing output file path');\n  } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {\n    err = new Error('Cannot use same file for input and output');\n  } else if (jp2Regex.test(path.extname(fileOut)) && !this.constructor.format.jp2k.output.file) {\n    err = errJp2Save();\n  }\n  if (err) {\n    if (is.fn(callback)) {\n      callback(err);\n    } else {\n      return Promise.reject(err);\n    }\n  } else {\n    this.options.fileOut = fileOut;\n    const stack = Error();\n    return this._pipeline(callback, stack);\n  }\n  return this;\n}\n\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.\n *\n * Use {@link #toformat|toFormat} or one of the format-specific functions such as {@link jpeg}, {@link png} etc. to set the output format.\n *\n * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .png()\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * const { data, info } = await sharp('my-image.jpg')\n *   // output the raw pixels\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * // create a more type safe way to work with the raw pixel data\n * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer\n * // so `data` and `pixelArray` point to the same memory location\n * const pixelArray = new Uint8ClampedArray(data.buffer);\n *\n * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input\n * const { width, height, channels } = info;\n * await sharp(pixelArray, { raw: { width, height, channels } })\n *   .toFile('my-changed-image.jpg');\n *\n * @param {Object} [options]\n * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\nfunction toBuffer (options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n  this.options.fileOut = '';\n  const stack = Error();\n  return this._pipeline(is.fn(options) ? options : callback, stack);\n}\n\n/**\n * Keep all EXIF metadata from the input image in the output image.\n *\n * EXIF metadata is unsupported for TIFF output.\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithExif = await sharp(inputWithExif)\n *   .keepExif()\n *   .toBuffer();\n *\n * @returns {Sharp}\n */\nfunction keepExif () {\n  this.options.keepMetadata |= 0b00001;\n  return this;\n}\n\n/**\n * Set EXIF metadata in the output image, ignoring any EXIF in the input image.\n *\n * @since 0.33.0\n *\n * @example\n * const dataWithExif = await sharp(input)\n *   .withExif({\n *     IFD0: {\n *       Copyright: 'The National Gallery'\n *     },\n *     IFD3: {\n *       GPSLatitudeRef: 'N',\n *       GPSLatitude: '51/1 30/1 3230/100',\n *       GPSLongitudeRef: 'W',\n *       GPSLongitude: '0/1 7/1 4366/100'\n *     }\n *   })\n *   .toBuffer();\n *\n * @param {Object<string, Object<string, string>>} exif Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withExif (exif) {\n  if (is.object(exif)) {\n    for (const [ifd, entries] of Object.entries(exif)) {\n      if (is.object(entries)) {\n        for (const [k, v] of Object.entries(entries)) {\n          if (is.string(v)) {\n            this.options.withExif[`exif-${ifd.toLowerCase()}-${k}`] = v;\n          } else {\n            throw is.invalidParameterError(`${ifd}.${k}`, 'string', v);\n          }\n        }\n      } else {\n        throw is.invalidParameterError(ifd, 'object', entries);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('exif', 'object', exif);\n  }\n  this.options.withExifMerge = false;\n  return this.keepExif();\n}\n\n/**\n * Update EXIF metadata from the input image in the output image.\n *\n * @since 0.33.0\n *\n * @example\n * const dataWithMergedExif = await sharp(inputWithExif)\n *   .withExifMerge({\n *     IFD0: {\n *       Copyright: 'The National Gallery'\n *     }\n *   })\n *   .toBuffer();\n *\n * @param {Object<string, Object<string, string>>} exif Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withExifMerge (exif) {\n  this.withExif(exif);\n  this.options.withExifMerge = true;\n  return this;\n}\n\n/**\n * Keep ICC profile from the input image in the output image.\n *\n * Where necessary, will attempt to convert the output colour space to match the profile.\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithIccProfile = await sharp(inputWithIccProfile)\n *   .keepIccProfile()\n *   .toBuffer();\n *\n * @returns {Sharp}\n */\nfunction keepIccProfile () {\n  this.options.keepMetadata |= 0b01000;\n  return this;\n}\n\n/**\n * Transform using an ICC profile and attach to the output image.\n *\n * This can either be an absolute filesystem path or\n * built-in profile name (`srgb`, `p3`, `cmyk`).\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithP3 = await sharp(input)\n *   .withIccProfile('p3')\n *   .toBuffer();\n *\n * @param {string} icc - Absolute filesystem path to output ICC profile or built-in profile name (srgb, p3, cmyk).\n * @param {Object} [options]\n * @param {number} [options.attach=true] Should the ICC profile be included in the output image metadata?\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withIccProfile (icc, options) {\n  if (is.string(icc)) {\n    this.options.withIccProfile = icc;\n  } else {\n    throw is.invalidParameterError('icc', 'string', icc);\n  }\n  this.keepIccProfile();\n  if (is.object(options)) {\n    if (is.defined(options.attach)) {\n      if (is.bool(options.attach)) {\n        if (!options.attach) {\n          this.options.keepMetadata &= ~0b01000;\n        }\n      } else {\n        throw is.invalidParameterError('attach', 'boolean', options.attach);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Keep all metadata (EXIF, ICC, XMP, IPTC) from the input image in the output image.\n *\n * The default behaviour, when `keepMetadata` is not used, is to convert to the device-independent\n * sRGB colour space and strip all metadata, including the removal of any ICC profile.\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithMetadata = await sharp(inputWithMetadata)\n *   .keepMetadata()\n *   .toBuffer();\n *\n * @returns {Sharp}\n */\nfunction keepMetadata () {\n  this.options.keepMetadata = 0b11111;\n  return this;\n}\n\n/**\n * Keep most metadata (EXIF, XMP, IPTC) from the input image in the output image.\n *\n * This will also convert to and add a web-friendly sRGB ICC profile if appropriate.\n *\n * Allows orientation and density to be set or updated.\n *\n * @example\n * const outputSrgbWithMetadata = await sharp(inputRgbWithMetadata)\n *   .withMetadata()\n *   .toBuffer();\n *\n * @example\n * // Set output metadata to 96 DPI\n * const data = await sharp(input)\n *   .withMetadata({ density: 96 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.orientation] Used to update the EXIF `Orientation` tag, integer between 1 and 8.\n * @param {number} [options.density] Number of pixels per inch (DPI).\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withMetadata (options) {\n  this.keepMetadata();\n  this.withIccProfile('srgb');\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n    if (is.defined(options.density)) {\n      if (is.number(options.density) && options.density > 0) {\n        this.options.withMetadataDensity = options.density;\n      } else {\n        throw is.invalidParameterError('density', 'positive number', options.density);\n      }\n    }\n    if (is.defined(options.icc)) {\n      this.withIccProfile(options.icc);\n    }\n    if (is.defined(options.exif)) {\n      this.withExifMerge(options.exif);\n    }\n  }\n  return this;\n}\n\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(string|Object)} format - as a string or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\nfunction toFormat (format, options) {\n  const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n  return this[actualFormat](options);\n}\n\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @example\n * // Use mozjpeg to reduce output JPEG file size (slower)\n * const data = await sharp(input)\n *   .jpeg({ mozjpeg: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {string} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling otherwise defaults to '4:2:0' chroma subsampling\n * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`\n * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation\n * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing\n * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive\n * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8\n * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jpeg (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n    if (is.defined(options.mozjpeg)) {\n      if (is.bool(options.mozjpeg)) {\n        if (options.mozjpeg) {\n          this.options.jpegTrellisQuantisation = true;\n          this.options.jpegOvershootDeringing = true;\n          this.options.jpegOptimiseScans = true;\n          this.options.jpegProgressive = true;\n          this.options.jpegQuantisationTable = 3;\n        }\n      } else {\n        throw is.invalidParameterError('mozjpeg', 'boolean', options.mozjpeg);\n      }\n    }\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n  return this._updateFormatOut('jpeg', options);\n}\n\n/**\n * Use these PNG options for output image.\n *\n * By default, PNG output is full colour at 8 bits per pixel.\n *\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n * Set `palette` to `true` for slower, indexed PNG output.\n *\n * For 16 bits per pixel output, convert to `rgb16` via\n * {@link /api-colour#tocolourspace|toColourspace}.\n *\n * @example\n * // Convert any input to full colour PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @example\n * // Convert any input to indexed PNG output (slower)\n * const data = await sharp(input)\n *   .png({ palette: true })\n *   .toBuffer();\n *\n * @example\n * // Output 16 bits per pixel RGB(A)\n * const data = await sharp(input)\n *  .toColourspace('rgb16')\n *  .png()\n *  .toBuffer();\n *\n * @param {Object} [options]\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)\n * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support\n * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`\n * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`\n * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction png (options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.pngBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n    } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {\n      this._setBooleanOption('pngPalette', true);\n    }\n    if (this.options.pngPalette) {\n      if (is.defined(options.quality)) {\n        if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n          this.options.pngQuality = options.quality;\n        } else {\n          throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n        }\n      }\n      if (is.defined(options.effort)) {\n        if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {\n          this.options.pngEffort = options.effort;\n        } else {\n          throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n        }\n      }\n      if (is.defined(options.dither)) {\n        if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n          this.options.pngDither = options.dither;\n        } else {\n          throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n        }\n      }\n    }\n  }\n  return this._updateFormatOut('png', options);\n}\n\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Optimise the file size of an animated WebP\n * const outputWebp = await sharp(inputWebp, { animated: true })\n *   .webp({ effort: 6 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {string} [options.preset='default'] - named preset for preprocessing/filtering, one of: default, photo, picture, drawing, icon, text\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.minSize=false] - prevent use of animation key frames to minimise file size (slow)\n * @param {boolean} [options.mixed=false] - allow mixture of lossy and lossless animation frames (slow)\n * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction webp (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.webpQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.alphaQuality)) {\n      if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n        this.options.webpAlphaQuality = options.alphaQuality;\n      } else {\n        throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      this._setBooleanOption('webpLossless', options.lossless);\n    }\n    if (is.defined(options.nearLossless)) {\n      this._setBooleanOption('webpNearLossless', options.nearLossless);\n    }\n    if (is.defined(options.smartSubsample)) {\n      this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n    }\n    if (is.defined(options.preset)) {\n      if (is.string(options.preset) && is.inArray(options.preset, ['default', 'photo', 'picture', 'drawing', 'icon', 'text'])) {\n        this.options.webpPreset = options.preset;\n      } else {\n        throw is.invalidParameterError('preset', 'one of: default, photo, picture, drawing, icon, text', options.preset);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {\n        this.options.webpEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 6', options.effort);\n      }\n    }\n    if (is.defined(options.minSize)) {\n      this._setBooleanOption('webpMinSize', options.minSize);\n    }\n    if (is.defined(options.mixed)) {\n      this._setBooleanOption('webpMixed', options.mixed);\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('webp', options);\n}\n\n/**\n * Use these GIF options for the output image.\n *\n * The first entry in the palette is reserved for transparency.\n *\n * The palette of the input image will be re-used if possible.\n *\n * @since 0.30.0\n *\n * @example\n * // Convert PNG to GIF\n * await sharp(pngBuffer)\n *   .gif()\n *   .toBuffer();\n *\n * @example\n * // Convert animated WebP to animated GIF\n * await sharp('animated.webp', { animated: true })\n *   .toFile('animated.gif');\n *\n * @example\n * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF\n * const out = await sharp('in.gif', { animated: true })\n *   .resize({ width: 128, height: 128 })\n *   .gif({ dither: 0 })\n *   .toBuffer();\n *\n * @example\n * // Lossy file size reduction of animated GIF\n * await sharp('in.gif', { animated: true })\n *   .gif({ interFrameMaxError: 8 })\n *   .toFile('optim.gif');\n *\n * @param {Object} [options] - output options\n * @param {boolean} [options.reuse=true] - re-use existing palette, otherwise generate new (slow)\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)\n * @param {number} [options.interFrameMaxError=0] - maximum inter-frame error for transparency, between 0 (lossless) and 32\n * @param {number} [options.interPaletteMaxError=3] - maximum inter-palette error for palette reuse, between 0 and 256\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction gif (options) {\n  if (is.object(options)) {\n    if (is.defined(options.reuse)) {\n      this._setBooleanOption('gifReuse', options.reuse);\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('gifProgressive', options.progressive);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.gifBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {\n        this.options.gifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n      }\n    }\n    if (is.defined(options.dither)) {\n      if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n        this.options.gifDither = options.dither;\n      } else {\n        throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n      }\n    }\n    if (is.defined(options.interFrameMaxError)) {\n      if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {\n        this.options.gifInterFrameMaxError = options.interFrameMaxError;\n      } else {\n        throw is.invalidParameterError('interFrameMaxError', 'number between 0.0 and 32.0', options.interFrameMaxError);\n      }\n    }\n    if (is.defined(options.interPaletteMaxError)) {\n      if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {\n        this.options.gifInterPaletteMaxError = options.interPaletteMaxError;\n      } else {\n        throw is.invalidParameterError('interPaletteMaxError', 'number between 0.0 and 256.0', options.interPaletteMaxError);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('gif', options);\n}\n\n/* istanbul ignore next */\n/**\n * Use these JP2 options for output image.\n *\n * Requires libvips compiled with support for OpenJPEG.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n * // Convert any input to lossless JP2 output\n * const data = await sharp(input)\n *   .jp2({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Convert any input to very high quality JP2 output\n * const data = await sharp(input)\n *   .jp2({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @since 0.29.1\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {number} [options.tileWidth=512] - horizontal tile size\n * @param {number} [options.tileHeight=512] - vertical tile size\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jp2 (options) {\n  if (!this.constructor.format.jp2k.output.buffer) {\n    throw errJp2Save();\n  }\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jp2Quality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jp2Lossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {\n        this.options.jp2TileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer between 1 and 32768', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {\n        this.options.jp2TileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer between 1 and 32768', options.tileHeight);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jp2ChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('jp2', options);\n}\n\n/**\n * Set animation options if available.\n * @private\n *\n * @param {Object} [source] - output options\n * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)\n * @param {Object} [target] - target object for valid options\n * @throws {Error} Invalid options\n */\nfunction trySetAnimationOptions (source, target) {\n  if (is.object(source) && is.defined(source.loop)) {\n    if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {\n      target.loop = source.loop;\n    } else {\n      throw is.invalidParameterError('loop', 'integer between 0 and 65535', source.loop);\n    }\n  }\n  if (is.object(source) && is.defined(source.delay)) {\n    // We allow singular values as well\n    if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {\n      target.delay = [source.delay];\n    } else if (\n      Array.isArray(source.delay) &&\n      source.delay.every(is.integer) &&\n      source.delay.every(v => is.inRange(v, 0, 65535))) {\n      target.delay = source.delay;\n    } else {\n      throw is.invalidParameterError('delay', 'integer or an array of integers between 0 and 65535', source.delay);\n    }\n  }\n}\n\n/**\n * Use these TIFF options for output image.\n *\n * The `density` can be set in pixels/inch via {@link #withmetadata|withMetadata}\n * instead of providing `xres` and `yres` in pixels/mm.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     bitdepth: 1\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {string} [options.compression='jpeg'] - compression options: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k\n * @param {string} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {boolean} [options.pyramid=false] - write an image pyramid\n * @param {boolean} [options.tile=false] - write a tiled tiff\n * @param {number} [options.tileWidth=256] - horizontal tile size\n * @param {number} [options.tileHeight=256] - vertical tile size\n * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {string} [options.resolutionUnit='inch'] - resolution unit options: inch, cm\n * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit\n * @param {boolean} [options.miniswhite=false] - write 1-bit images as miniswhite\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction tiff (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {\n        this.options.tiffBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '1, 2, 4 or 8', options.bitdepth);\n      }\n    }\n    // tiling\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    }\n    // miniswhite\n    if (is.defined(options.miniswhite)) {\n      this._setBooleanOption('tiffMiniswhite', options.miniswhite);\n    }\n    // pyramid\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    }\n    // resolution\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    }\n    // compression\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['none', 'jpeg', 'deflate', 'packbits', 'ccittfax4', 'lzw', 'webp', 'zstd', 'jp2k'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k', options.compression);\n      }\n    }\n    // predictor\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    }\n    // resolutionUnit\n    if (is.defined(options.resolutionUnit)) {\n      if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ['inch', 'cm'])) {\n        this.options.tiffResolutionUnit = options.resolutionUnit;\n      } else {\n        throw is.invalidParameterError('resolutionUnit', 'one of: inch, cm', options.resolutionUnit);\n      }\n    }\n  }\n  return this._updateFormatOut('tiff', options);\n}\n\n/**\n * Use these AVIF options for output image.\n *\n * AVIF image sequences are not supported.\n * Prebuilt binaries support a bitdepth of 8 only.\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ effort: 2 })\n *   .toBuffer();\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ lossless: true })\n *   .toBuffer();\n *\n * @since 0.27.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @param {number} [options.bitdepth=8] - set bitdepth to 8, 10 or 12 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction avif (options) {\n  return this.heif({ ...options, compression: 'av1' });\n}\n\n/**\n * Use these HEIF options for output image.\n *\n * Support for patent-encumbered HEIC images using `hevc` compression requires the use of a\n * globally-installed libvips compiled with support for libheif, libde265 and x265.\n *\n * @example\n * const data = await sharp(input)\n *   .heif({ compression: 'hevc' })\n *   .toBuffer();\n *\n * @since 0.23.0\n *\n * @param {Object} options - output options\n * @param {string} options.compression - compression format: av1, hevc\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @param {number} [options.bitdepth=8] - set bitdepth to 8, 10 or 12 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction heif (options) {\n  if (is.object(options)) {\n    if (is.string(options.compression) && is.inArray(options.compression, ['av1', 'hevc'])) {\n      this.options.heifCompression = options.compression;\n    } else {\n      throw is.invalidParameterError('compression', 'one of: av1, hevc', options.compression);\n    }\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {\n        this.options.heifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 9', options.effort);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [8, 10, 12])) {\n        if (options.bitdepth !== 8 && this.constructor.versions.heif) {\n          throw is.invalidParameterError('bitdepth when using prebuilt binaries', 8, options.bitdepth);\n        }\n        this.options.heifBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '8, 10 or 12', options.bitdepth);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('options', 'Object', options);\n  }\n  return this._updateFormatOut('heif', options);\n}\n\n/**\n * Use these JPEG-XL (JXL) options for output image.\n *\n * This feature is experimental, please do not use in production systems.\n *\n * Requires libvips compiled with support for libjxl.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * Image metadata (EXIF, XMP) is unsupported.\n *\n * @since 0.31.3\n *\n * @param {Object} [options] - output options\n * @param {number} [options.distance=1.0] - maximum encoding error, between 0 (highest quality) and 15 (lowest quality)\n * @param {number} [options.quality] - calculate `distance` based on JPEG-like quality, between 1 and 100, overrides distance if specified\n * @param {number} [options.decodingTier=0] - target decode speed tier, between 0 (highest quality) and 4 (lowest quality)\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=7] - CPU effort, between 3 (fastest) and 9 (slowest)\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jxl (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        // https://github.com/libjxl/libjxl/blob/0aeea7f180bafd6893c1db8072dcb67d2aa5b03d/tools/cjxl_main.cc#L640-L644\n        this.options.jxlDistance = options.quality >= 30\n          ? 0.1 + (100 - options.quality) * 0.09\n          : 53 / 3000 * options.quality * options.quality - 23 / 20 * options.quality + 25;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    } else if (is.defined(options.distance)) {\n      if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {\n        this.options.jxlDistance = options.distance;\n      } else {\n        throw is.invalidParameterError('distance', 'number between 0.0 and 15.0', options.distance);\n      }\n    }\n    if (is.defined(options.decodingTier)) {\n      if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {\n        this.options.jxlDecodingTier = options.decodingTier;\n      } else {\n        throw is.invalidParameterError('decodingTier', 'integer between 0 and 4', options.decodingTier);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jxlLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 3, 9)) {\n        this.options.jxlEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 3 and 9', options.effort);\n      }\n    }\n  }\n  return this._updateFormatOut('jxl', options);\n}\n\n/**\n * Force output to be raw, uncompressed pixel data.\n * Pixel ordering is left-to-right, top-to-bottom, without padding.\n * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.\n *\n * @example\n * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @example\n * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input\n * const data = await sharp('input.png')\n *   .ensureAlpha()\n *   .extractChannel(3)\n *   .toColourspace('b-w')\n *   .raw({ depth: 'ushort' })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {string} [options.depth='uchar'] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction raw (options) {\n  if (is.object(options)) {\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth,\n        ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'complex', 'double', 'dpcomplex']\n      )) {\n        this.options.rawDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex', options.depth);\n      }\n    }\n  }\n  return this._updateFormatOut('raw');\n}\n\n/**\n * Use tile-based deep zoom (image pyramid) output.\n *\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * The container will be set to `zip` when the output is a Buffer or Stream, otherwise it will default to `fs`.\n *\n * Requires libvips compiled with support for libgsf.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @example\n * const zipFileWithTiles = await sharp(input)\n *   .tile({ basename: \"tiles\" })\n *   .toBuffer();\n *\n * @example\n * const iiififier = sharp().tile({ layout: \"iiif\" });\n * readableStream\n *   .pipe(iiififier)\n *   .pipe(writeableStream);\n *\n * @param {Object} [options]\n * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {number} [options.skipBlanks=-1] Threshold to skip tile generation. Range is 0-255 for 8-bit images, 0-65535 for 16-bit images. Default is 5 for `google` layout, -1 (no skip) otherwise.\n * @param {string} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {string} [options.layout='dz'] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.\n * @param {boolean} [options.centre=false] centre image in tile.\n * @param {boolean} [options.center=false] alternative spelling of centre.\n * @param {string} [options.id='https://example.com/iiif'] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`\n * @param {string} [options.basename] the name of the directory within the zip file when container is `zip`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction tile (options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    }\n    // Overlap of tiles, in pixels\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    }\n    // Container\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    }\n    // Layout\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'iiif', 'iiif3', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, iiif, iiif3, zoomify', options.layout);\n      }\n    }\n    // Angle of rotation,\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    }\n    // Background colour\n    this._setBackgroundColourOption('tileBackground', options.background);\n    // Depth of tiles\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    }\n    // Threshold to skip blank tiles\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    }\n    // Center image in tile\n    const centre = is.bool(options.center) ? options.center : options.centre;\n    if (is.defined(centre)) {\n      this._setBooleanOption('tileCentre', centre);\n    }\n    // @id attribute for IIIF layout\n    if (is.defined(options.id)) {\n      if (is.string(options.id)) {\n        this.options.tileId = options.id;\n      } else {\n        throw is.invalidParameterError('id', 'string', options.id);\n      }\n    }\n    // Basename for zip container\n    if (is.defined(options.basename)) {\n      if (is.string(options.basename)) {\n        this.options.tileBasename = options.basename;\n      } else {\n        throw is.invalidParameterError('basename', 'string', options.basename);\n      }\n    }\n  }\n  // Format\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n  return this._updateFormatOut('dz');\n}\n\n/**\n * Set a timeout for processing, in seconds.\n * Use a value of zero to continue processing indefinitely, the default behaviour.\n *\n * The clock starts when libvips opens an input image for processing.\n * Time spent waiting for a libuv thread to become available is not included.\n *\n * @example\n * // Ensure processing takes no longer than 3 seconds\n * try {\n *   const data = await sharp(input)\n *     .blur(1000)\n *     .timeout({ seconds: 3 })\n *     .toBuffer();\n * } catch (err) {\n *   if (err.message.includes('timeout')) { ... }\n * }\n *\n * @since 0.29.2\n *\n * @param {Object} options\n * @param {number} options.seconds - Number of seconds after which processing will be stopped\n * @returns {Sharp}\n */\nfunction timeout (options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n  if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {\n    this.options.timeoutSeconds = options.seconds;\n  } else {\n    throw is.invalidParameterError('seconds', 'integer between 0 and 3600', options.seconds);\n  }\n  return this;\n}\n\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {string} formatOut\n * @param {Object} [options]\n * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\nfunction _updateFormatOut (formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n  return this;\n}\n\n/**\n * Update a boolean attribute of the this.options Object.\n * @private\n * @param {string} key\n * @param {boolean} val\n * @throws {Error} Invalid key\n */\nfunction _setBooleanOption (key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\nfunction _read () {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n    const stack = Error();\n    this._pipeline(undefined, stack);\n  }\n}\n\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\nfunction _pipeline (callback, stack) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            callback(is.nativeError(err, stack));\n          } else {\n            callback(null, data, info);\n          }\n        });\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          callback(is.nativeError(err, stack));\n        } else {\n          callback(null, data, info);\n        }\n      });\n    }\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', is.nativeError(err, stack));\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n          this.push(null);\n          this.on('end', () => this.emit('close'));\n        });\n      });\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', is.nativeError(err, stack));\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n        this.push(null);\n        this.on('end', () => this.emit('close'));\n      });\n    }\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(is.nativeError(err, stack));\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({ data, info });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(is.nativeError(err, stack));\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({ data, info });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    keepExif,\n    withExif,\n    withExifMerge,\n    keepIccProfile,\n    withIccProfile,\n    keepMetadata,\n    withMetadata,\n    toFormat,\n    jpeg,\n    jp2,\n    png,\n    webp,\n    tiff,\n    avif,\n    heif,\n    jxl,\n    gif,\n    raw,\n    tile,\n    timeout,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}